---
description: SOLID, interview gatekeeping or the key factor between a project's success or failure?
categories: [Coding principles]
post_title: SOLID
---

The SOLID principles were first instantiated into existence in the early 2000s. They are a set of principles that are used to help you structure your code base. They will help projects to cleanly grow in complexity and avoid issues further down the line. That's the theory behind them at least. I often find that they only get spoken about when someone's job hunting as it's a question that "will definitely come up" to test your foundational knowledge. Or it's just a fun bit of trivia amongst your fellow software devs. In most working environments I've been in it's never really come up as a concrete set of rules that are critical when building out new features. 

So, are these principles merely used for gatekeeping in interviews? Are they still relevant more than two decades on since they were first promoted? Are they principles that get applied on a daily basis without us giving them much thought? Let's dig in a little further.

## What are the SOLID principles?

A good place to start is to list the five principles.

- **S**: Single Responsibility
- **O**: Open/Closed
- **L**: Liskov Substitution
- **I**: Interface Segregation
- **D**: Dependency Inversion

So, job done? Did I get the job? Not quite, unless I'm a literal parrot :parrot:. You need to be able to at the very least explain the principles in some detail. That should start to give some explanation for why they are deemed important.

I find some are easier to understand than others. I find Liskov's substitution the most abstract to fully grasp. A couple of them make complete sense to me. That doesn't mean they should be blindly followed. A little bit of critical thinking is never a bad thing before diving into the implementation.

### Single Responsibility Principle

This is one of the easiest principles to understand. Basically a class (an object) should have one responsibility that it handles.

Let's say we had a `Report` class. It currently formats, prints, and saves the report. We might add more functionality in the future. All these responsibilities are related to reports but confining them all into one class can have several downsides. Some that come to my mind are:

- Files can quickly become large (excessive scrolling intensifies).
- Potential for errors creeping in can increase.
- Test coverage for all methods can be harder to track.
- The potential for merge conflicts increases if several people are working on the same class at one time.
- Redundant code may get left behind as the class updates overtime.

### Open/Closed Principle

Another principle that is fairly easy to grasp. Code should be **open** to extension but **closed** to modification. You shouldn't be editing existing classes/methods.

We have an existing `PaymentProcessor` class. We're adding some new payment methods. We could keep updating the main `ProcessPayment` method to accommodate these new payment methods but this breaks this principle. Some issues from handling these changes like this are:

- Files become bloated.
- Logic errors can creep in to the original implementation.
- We end up updating existing and robust unit tests to fit with the code changes.

Rather we should look for ways to extend the existing functionality. Two such ways are:

- Taking a *Decorator pattern* approach by creating an interface that new types/classes implement.
- Creating extension methods.

### Liskov Substitution Principle

Liskov presents the principle that I found the hardest to grasp of the lot. Once you've thought it through and looked at enough examples it starts to become clear. This principle says that a subclass should be usable anywhere that the base class can be used, without breaking.

We have a `Bird` base class. It has a method called `Fly`. We create several subclasses that inherit from Bird. The Fly method works fine when the bird is a Sparrow. If the bird is a Penguin then there is an issue. Penguins may have happy feet but they don't have happy wings. An issue with this is that developers will expect all subclasses to be able to use the base class methods.

### Interface Segregation Principle

This principle has two man benefits. It helps make your code more manageable as it grows over time. It also prevents methods from implementing methods they do not need (which also violates the Liskov Substitution principle).

Let's say we have an `IPrinter` interface. It contains methods for `Print`, `Scan`, and `Fax`. This can be a problem when the printer classes that implement this interface don't require all the methods. It's safe to assume all printers will require the Print method. The issue is that many printers don't have scan or fax functionalities. So, the main issues without segregating your interfaces are:

- Classes implement methods they shouldn't have to.
- Interfaces can become bloated and hard to maintain the more unrelated methods you add to them.

### Dependency Inversion Principle

## SOLID in practice

Now that we have a decent understanding of the five principles let's look at some practical examples. I'll use the examples from above to show code snippets of how these principles can be violated and a correct implementation.

### Single Responsibility Principle

### Open/Closed Principle

**Problem scenario**:

```
public class PaymentProcessor
{
    public void ProcessPayment(string method, decimal amount)
    {
        if (method == "CreditCard")
        {
            // credit card logic
        }
        else if (method == "PayPal")
        {
            // PayPal logic
        }
        else if (method == "DogeCoin")
        {
            // DogeCoin logic
        }
        // etc...
    }
}
```

Every time we add a new payment type we have to modify existing code. This could break the existing logic that works correctly. The class can grow excessively.

**Correct implementation**:

```
public interface IPaymentMethod
{
    void Pay(decimal amount);
}

public class CreditCardPayment : IPaymentMethod
{
    public void Pay(decimal amount)
    {
        Console.WriteLine($"Paid {amount} with Credit Card.");
    }
}

public class PayPalPayment : IPaymentMethod
{
    public void Pay(decimal amount)
    {
        Console.WriteLine($"Paid {amount} with PayPal.");
    }
}
```

```
public class PaymentProcessor
{
    public void Process(IPaymentMethod paymentMethod, decimal amount)
    {
        paymentMethod.Pay(amount);
    }
}
```

Now we don't have to touch `PaymentProcessor`. We don't have to add a new `if` statement for every new payment type. No need to touch working code that already exists.

### Liskov Substitution Principle

**Problem scenario**:

```
public class Bird
{
    public virtual void Fly()
    {
        Console.WriteLine("The bird is flying.");
    }
}

public class Sparrow : Bird
{
    public override void Fly()
    {
        Console.WriteLine("Sparrow flying...");
    }
}

public class Penguin : Bird
{
    public override void Fly()
    {
        throw new NotSupportedException("Penguins cannot fly!");
    }
}
```

```
void MakeBirdFly(Bird bird)
{
    bird.Fly(); // crashes if it's a Penguin
}
```

If you pass `Sparrow` into `MakeBirdFly` it works fine. If you pass in `Penguin` it causes an exception. This means Penguin cannot safely substitute Bird which is a violation of Liskov Substitution Principle.

**Correct implementation**:

```
public interface IFlyingBird
{
    void Fly();
}

public class Sparrow : Bird, IFlyingBird
{
    public void Fly()
    {
        Console.WriteLine("Sparrow flying...");
    }
}

public class Penguin : Bird
{
    public void Swim()
    {
        Console.WriteLine("Penguin swimming...");
    }
}

```

```
void MakeSomethingFly(IFlyingBird bird)
{
    bird.Fly();  // Always valid
}
```
Rather create an `IFlyingBird` interface. Both Sparrow and Penguin are still subclasses of Bird but only Sparrow implements the interface. Penguin instead has a `Swim` method instead of implementing the `Fly` method. Then when you want to use the Fly method you cannot accidentally pass in the Penguin type.

### Interface Segregation Principle

**Problem scenario**:

```
public interface IPrinter
{
    void Print(string content);
    void Scan(string content);
    void Fax(string content);
}

public class BasicPrinter : IPrinter
{
    public void Print(string content)
    {
        Console.WriteLine("Printing...");
    }

    public void Scan(string content)
    {
        throw new NotSupportedException("This printer cannot scan.");
    }

    public void Fax(string content)
    {
        throw new NotSupportedException("This printer cannot fax.");
    }
}
```

```
IPrinter printer = new BasicPrinter();
printer.Fax("Hello");  // Hello Exception
```

IPrinter cannot be safely used as many classes implementing it may throw exceptions if they cannot correctly implement these methods.

**Correct implementation**:

```
public interface IPrint
{
    void Print(string content);
}

public interface IScan
{
    void Scan(string content);
}

public interface IFax
{
    void Fax(string content);
}

public class BasicPrinter : IPrint
{
    public void Print(string content)
    {
        Console.WriteLine("Printing...");
    }
}

public class MultiFunctionPrinter : IPrint, IScan
{
    public void Print(string content)
    {
        Console.WriteLine("Printing...");
    }

    public void Scan(string content)
    {
        Console.WriteLine("Scanning...");
    }
}

```

```
void DoPrinting(IPrint printer)
{
    printer.Print("Hello!");
}
```

Now you would pass in any printer into a new `DoPrinting` method that can actually print.

### Dependency Inversion Principle

## Over doing SOLID

Like with anything in live you can over do these principles.

- Single Responsibility shouldn't mean it only does one job. It just means the jobs it does are closely related.

## Conclusion

My thoughts on SOLID

Good to know. Try think about them when coding. 
Not the end of the world if all are not used.
Depends on your project/ use case.

---
description: SOLID, interview gatekeeping or the key factor between a project's success or failure?
categories: [Coding principles]
post_title: SOLID
---

The SOLID principles were first introduced in the early 2000s. They are a set of principles that are used to help you structure your codebase. They will help projects to cleanly grow in complexity and avoid issues further down the line. That's the theory behind them, at least. I often find that they only get discussed when someone is job hunting, as it's a question that "will definitely come up" to test your foundational knowledge. Or it's just a fun bit of trivia among your fellow software devs. In most working environments I've been in, it never really gets raised when discussing new work. Maybe it's just assumed that we all follow the principles.

So, are these principles merely used for gatekeeping in interviews? Are they still relevant more than two decades on since they were first promoted? Are they principles that get applied on a daily basis without us giving them much thought? Let's dig in a little further.

## What are the SOLID principles?

A good place to start is to list the five principles.

- **S**: Single Responsibility
- **O**: Open/Closed
- **L**: Liskov Substitution
- **I**: Interface Segregation
- **D**: Dependency Inversion

So, job done? Did I get the job? Not quite, unless I'm a literal parrot ðŸ¦œ. You need to, at the very least, be able to explain the principles in some detail. That should start to give some explanation for why they are deemed important.

### Single Responsibility Principle

This is one of the easiest principles to understand. Basically a class (an object) should have one responsibility that it handles.

Let's say we had a `Report` class. It currently generates, formats, and saves the report. We might add more functionality in the future. All these responsibilities are related to reports, but confining them to a single class can have several downsides. Some that come to my mind are:

- Files can quickly become large (excessive scrolling intensifies).
- Potential for errors creeping in can increase.
- Test coverage for all methods can be harder to track.
- The potential for merge conflicts increases if several people are working on the same class at one time.
- Redundant code may get left behind as the class updates over time.

### Open/Closed Principle

Another principle that is fairly easy to grasp. Code should be **open** to extension but **closed** to modification. You shouldn't be editing existing classes or methods.

We have an existing `PaymentProcessor` class. We're adding some new payment methods. We could keep updating the main `ProcessPayment` method to accommodate these new payment methods but this breaks this principle. Some issues from handling these changes like this are:

- Files become bloated.
- Logic errors can creep in to the original implementation.
- We end up updating existing and robust unit tests to fit with the code changes.

Rather we should look for ways to extend the existing functionality. Two such ways are:

- Taking a *Decorator pattern* approach by creating an interface that new types/classes implement.
- Creating extension methods.

### Liskov Substitution Principle

The Liskov Substitution Principle is the most abstract of the lot. Once you've thought it through and looked at enough examples it starts to become clear. This principle says that a subclass should be usable anywhere that the base class can be used, without breaking.

We have a `Bird` base class. It has a method called `Fly`. We create several subclasses that inherit from Bird. The Fly method works fine when the bird is a `Sparrow`. If the bird is a `Penguin`, then there is an issue. Penguins may have happy feet, but they don't have happy wings. An issue with this is that developers will expect all subclasses to be able to use the base class methods.

### Interface Segregation Principle

This principle has two main benefits. It helps make your code more manageable as it grows over time. It also prevents classes from being forced to implement methods they do not need (which also violates the Liskov Substitution Principle).

Let's say we have an `IPrinter` interface. It contains methods for `Print`, `Scan`, and `Fax`. This can be a problem when the printer classes that implement this interface don't require all the methods. It's safe to assume all printers will require the Print method. The issue is that many printers don't have scan or fax functionalities. So, the main issues without segregating your interfaces are:

- Classes implement methods they shouldn't have to.
- Interfaces can become bloated and hard to maintain the more unrelated methods you add to them.

### Dependency Inversion Principle

This principle says that high-level modules shouldn't depend on low-level modules. They should both depend on abstraction. When you violate this principle, you end up tightly coupling modules.

A `NotificationService` (the high-level logic) that instantiates an `EmailSender` class (low-level detail) becomes directly dependent on this concrete instantiation. The only type of notifications this NotificationService can now perform is emails. There are several other issues that this causes:

- You cannot switch to other forms of notifications such as SMS, Slack, etc. without having to modify the service.
- The service is harder to test because you can't mock EmailSender.
- Every change in EmailSender potentially means a change in the service too.


## SOLID in practice

Now that we have a decent understanding of the five principles let's look at some practical examples. I'll use the examples from above to show code snippets of how these principles can be violated and a correct implementation.

### Single Responsibility Principle

**Problem scenario**:

```
public class Report
{
    public string Title { get; set; }
    public string Content { get; set; }

    // Business responsibility
    public void Generate()
    {
        Console.WriteLine("Generating report content...");
    }

    // Formatting responsibility
    public string FormatAsPdf()
    {
        return $"<PDF>{Title}\n{Content}</PDF>";
    }

    // Persistence responsibility
    public void SaveToFile(string path)
    {
        File.WriteAllText(path, Content);
    }
}
```
This class has the potential to grow very large which will make testing difficult and possibly introduce bugs. The methods all perform functionality relating to reports but they all serve very different purposes.

**Correct implementation**:

```
public class Report
{
    public string Title { get; set; }
    public string Content { get; set; }
}

public class ReportGenerator
{
    public Report Generate()
    {
        return new Report
        {
            Title = "Monthly Report",
            Content = "Some report data..."
        };
    }
}

public class ReportFormatter
{
    public string FormatAsPdf(Report report)
    {
        return $"<PDF>{report.Title}\n{report.Content}</PDF>";
    }
}

public class ReportRepository
{
    public void Save(string path, string content)
    {
        File.WriteAllText(path, content);
    }
}

```

```
var generator = new ReportGenerator();
var formatter = new ReportFormatter();
var repository = new ReportRepository();

var report = generator.Generate();
var pdf = formatter.FormatAsPdf(report);

repository.Save("report.pdf", pdf);
```
This approach results in each class being modular. You can swap out components with ease.

### Open/Closed Principle

**Problem scenario**:

```
public class PaymentProcessor
{
    public void ProcessPayment(string method, decimal amount)
    {
        if (method == "CreditCard")
        {
            // credit card logic
        }
        else if (method == "PayPal")
        {
            // PayPal logic
        }
        else if (method == "DogeCoin")
        {
            // DogeCoin logic
        }
        // etc...
    }
}
```
Every time we add a new payment type we have to modify existing code. This could break the existing logic that works correctly. The class can also grow excessively.

**Correct implementation**:

```
public interface IPaymentMethod
{
    void Pay(decimal amount);
}

public class CreditCardPayment : IPaymentMethod
{
    public void Pay(decimal amount)
    {
        Console.WriteLine($"Paid {amount} with Credit Card.");
    }
}

public class PayPalPayment : IPaymentMethod
{
    public void Pay(decimal amount)
    {
        Console.WriteLine($"Paid {amount} with PayPal.");
    }
}
```

```
public class PaymentProcessor
{
    public void Process(IPaymentMethod paymentMethod, decimal amount)
    {
        paymentMethod.Pay(amount);
    }
}
```

Now we don't have to touch `PaymentProcessor`. We don't have to add a new `if` statement for every new payment type. No need to touch working code that already exists.

### Liskov Substitution Principle

**Problem scenario**:

```
public class Bird
{
    public virtual void Fly()
    {
        Console.WriteLine("The bird is flying.");
    }
}

public class Sparrow : Bird
{
    public override void Fly()
    {
        Console.WriteLine("Sparrow flying...");
    }
}

public class Penguin : Bird
{
    public override void Fly()
    {
        throw new NotSupportedException("Penguins cannot fly!");
    }
}
```

```
void MakeBirdFly(Bird bird)
{
    bird.Fly(); // crashes if it's a Penguin
}
```

If you pass `Sparrow` into `MakeBirdFly` it works fine. If you pass in `Penguin` it causes an exception. This means Penguin cannot safely substitute Bird which is a violation of Liskov Substitution Principle.

**Correct implementation**:

```
public interface IFlyingBird
{
    void Fly();
}

public class Sparrow : Bird, IFlyingBird
{
    public void Fly()
    {
        Console.WriteLine("Sparrow flying...");
    }
}

public class Penguin : Bird
{
    public void Swim()
    {
        Console.WriteLine("Penguin swimming...");
    }
}

```

```
void MakeSomethingFly(IFlyingBird bird)
{
    bird.Fly();  // Always valid
}
```
Rather create an `IFlyingBird` interface. Both Sparrow and Penguin are still subclasses of Bird but only Sparrow implements the interface. Penguin instead has a `Swim` method instead of implementing the `Fly` method. Then when you want to use the Fly method you cannot accidentally pass in the Penguin type.

### Interface Segregation Principle

**Problem scenario**:

```
public interface IPrinter
{
    void Print(string content);
    void Scan(string content);
    void Fax(string content);
}

public class BasicPrinter : IPrinter
{
    public void Print(string content)
    {
        Console.WriteLine("Printing...");
    }

    public void Scan(string content)
    {
        throw new NotSupportedException("This printer cannot scan.");
    }

    public void Fax(string content)
    {
        throw new NotSupportedException("This printer cannot fax.");
    }
}
```

```
IPrinter printer = new BasicPrinter();
printer.Fax("Hello");  // Hello Exception
```

`IPrinter` cannot be safely used as many classes implementing it may throw exceptions if they cannot correctly implement these methods.

**Correct implementation**:

```
public interface IPrint
{
    void Print(string content);
}

public interface IScan
{
    void Scan(string content);
}

public interface IFax
{
    void Fax(string content);
}

public class BasicPrinter : IPrint
{
    public void Print(string content)
    {
        Console.WriteLine("Printing...");
    }
}

public class MultiFunctionPrinter : IPrint, IScan
{
    public void Print(string content)
    {
        Console.WriteLine("Printing...");
    }

    public void Scan(string content)
    {
        Console.WriteLine("Scanning...");
    }
}

```

```
void DoPrinting(IPrint printer)
{
    printer.Print("Hello!");
}
```

Now you would pass in any printer into a new `DoPrinting` method that can actually print.

### Dependency Inversion Principle

**Problem scenario**:

```
public class EmailSender
{
    public void Send(string message)
    {
        Console.WriteLine("Sending email: " + message);
    }
}

public class NotificationService
{
    private readonly EmailSender _emailSender;

    public NotificationService()
    {
        _emailSender = new EmailSender();  // directly instantiating dependency
    }

    public void Notify(string message)
    {
        _emailSender.Send(message);
    }
}
```
`NotificationService` is now tightly coupled to `EmailSender`. Both classes should rather depend on abstraction.

**Correct implementation**:

```
public interface IMessageSender
{
    void Send(string message);
}

public class EmailSender : IMessageSender
{
    public void Send(string message)
    {
        Console.WriteLine("Sending email: " + message);
    }
}

public class SmsSender : IMessageSender
{
    public void Send(string message)
    {
        Console.WriteLine("Sending SMS: " + message);
    }
}
```

```
public class NotificationService
{
    private readonly IMessageSender _sender;

    public NotificationService(IMessageSender sender)
    {
        _sender = sender;   // depends on abstraction
    }

    public void Notify(string message)
    {
        _sender.Send(message);
    }
}
```
Now the service (high-level module) depends on an interface. The different notification types are sent in using dependency injection. The service does not care *how* the message gets delivered. All it needs is for a sender to be injected.

## Overdoing SOLID

Like anything in life, you can overdo these principles. Some basic examples of overdoing a couple of these principles are the following:

- Single Responsibility shouldn't mean it only does one job. It just means the jobs it does are closely related. You could go to the opposite extreme of one massive bloated file by creating an excessive number of small classes that hold one property and one method apiece.
- Never making any updates to existing classes or methods because it would break the closed nature of existing code. While you generally wouldn't want to alter exiting behavior there might be legitimate cases where the business logic has to fundamentally change. Refactoring might add performance boosts while leaving the existing logic unchanged.
- Being afraid to use inheritance because it might violate the Liskov Substitution Principle can lead to avoiding inheritance entirely, even for classes that would naturally be subclasses of a base class.
- Interfaces can be too segregated if there is only one method per interface. There might be legitimate cases where this is appropriate, but generally there are at least a couple of methods per interface.

## Conclusion

So, to answer the question(s) I posed at the beginning of this post. I don't think these principles are merely about gatekeeping in interviews. They are still relevant two decades on from when they were grouped together. These rules help you think about how to better structure your projects and, hopefully, write better code. I don't think they get spoken about specifically when actually creating new features. If I go look at some code I've written recently I can see examples of these principles. It's not a bad thing that it often gets asked in interview settings. It's good to see if a candidate knows some core principles; it also helps the candidate show how they think about and approach coding.

Something to be aware of is that you're not going to see all five principles in play together all the time. If a new feature you've implemented only contains a couple of the principles, it doesn't mean you need to shoehorn in the rest to complete the acronym. It's not the end of the world if you don't use them all (or any). Not using them does not signal your project will fail. Though in the long run if you don't follow them it could come back to bite you. As your project grows you might find yourself having to come up with creative hacks to get all the classes and interfaces to play nicely with one another. 

The examples used in this post were simple to grasp plus they illustrated clear benefits of implementing these principles. In real world projects it won't always be so clear cut. As with everything in life you will gain a knack for knowing when the best time to use these principles is the more you develop. Being aware of these principles and using them as guides rather than laws you must obey will help you write better code and think up cleaner solutions.